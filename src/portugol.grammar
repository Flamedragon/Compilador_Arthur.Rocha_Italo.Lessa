Package portugol;

Helpers
	digit_excluding_zero = ['1'..'9'];
	digit = ['0'..'9'];
	lowercase = ['a'..'z'];
	uppercase = ['A'..'Z'];
	letter = lowercase | uppercase ;
	cr = 13;
	lf = 10;
	tab = 9;
	anything = [0..0xffff];

States
	normal,
	comment;

Tokens
	{normal}program = 'programa';
	{normal}begin = 'inicio';
	{normal}end = 'fim';
	{normal}dot = '.';
	{normal}colon = ':';
	{normal}semicolon = ';';
	{normal}const = 'const';
	{normal}comma = ',';
	{normal}real = 'real';
	{normal}integer = 'inteiro';
	{normal}char = 'charactere';
	{normal}l_bkt = '[';
	{normal}r_bkt = ']';
	{normal}l_arrow = '<-';
	{normal}read = 'leia';
	{normal}l_par = '(';
	{normal}r_par = ')';
	{normal}write = 'escreva';
	{normal}if = 'se';
	{normal}then = 'entao';
	{normal}else = 'senao';
	{normal}end_if = 'fim se';
	{normal}evaluate = 'avalie';
	{normal}case = 'caso';
	{normal}end_evaluate = 'fim avalie';
	{normal}while = 'enquanto';
	{normal}do = 'faca';
	{normal}end_while = 'fim enquanto';
	{normal}repeat = 'repita';
	{normal}until = 'ate';
	{normal}for = 'para';
	{normal}of = 'de';
	{normal}step = 'passo';
	{normal}end_for = 'fim para';	
	{normal}minus = '-';
	{normal}plus = '+';
	{normal}star = '*';
	{normal}bar = '/';
	{normal}equal = '=';
	{normal}not_equal = '<>';
	{normal}l_equal = '<=';
	{normal}g_equal = '>=';
	{normal}less = '<';
	{normal}greater = '>';
	{normal}not = 'nao';
	{normal}and = 'e';
	{normal}or = 'ou';
	{normal}xor = 'xor';

	{normal}id = (letter | '_') (letter | digit | '_')*;
	{normal}line_comment = '//' [anything - [cr + lf ]]*  (lf cr | lf | cr );
	
	{normal->comment,comment}block_commnet_start = '/*';
	{comment->normal}block_comment_end = '*/';
	{comment}block_comment_body = ([anything - ['*'+'/']]*) | ('*' | '/');

	{normal}string = ''' ( letter | digit )* ''';
	{normal}vector = (letter | '_') (letter | digit | '_')* '[' digit* ']';
	{normal}n_int = '-'? digit digit*;
	{normal}n_real = digit digit* '.' digit digit*;
	{normal}blank = (' ' | cr | lf | tab)+;

Ignored Tokens
	blank;

/*
Productions

	programa = program id begin declaracao* comando* end dot;

	declaracao = tipo colon var_comma* var semicolon;

	var_comma = var comma;

	comando_semicolon = {comando_semicolon} comando semicolon;

	comando_colon = {comando_colon} comando colon;

	exp_comma = exp comma;
	
	tipo =  {real} real|
			{integer} integer| 
			{char} char;

	var = {id} id| id l_bkt n_int r_bkt;

	valor = {string} string | {n_int} n_int | {n_real} n_real;

	else_comando_colon = else comando_colon* comando semicolon;
	else_colon_comando = else colon comando_semicolon* comando semicolon;
	case_valor = case valor colon comando_semicolon* comando semicolon;
	
	comando = {var} var l_arrow exp semicolon
						| {read} read l_par var_comma* var r_par semicolon
						| {write} write l_par exp_comma* exp r_par  
						| {if} if l_par exp_logica r_par then comando_semicolon+ else_comando_colon? end_if semicolon
						| {evaluate} evaluate l_par exp r_par case_valor* else_colon_comando? end_evaluate semicolon
						| {while} while l_par exp_logica r_par do comando_semicolon+ end_while semicolon
						| {repeat} repeat comando_semicolon+ until l_par exp_logica r_par semicolon
						| {for} for var of [startn]:n_int until [end_n]:n_int do comando_semicolon+ end_for semicolon
						| {for_each} var of [startn]:n_int step n_int until [end_n]:n_int do comando_semicolon+ end_for semicolon;

	exp = {valor} valor
				|{exp_var} var
				| {exp_par} l_par exp r_par
				| {negative_exp} minus exp 
				| {add} [termo1]:exp plus exp
				| {subtract} [termo1]:exp minus exp
				| {mult} [termo1]:exp star exp
				| {div} [termo1]:exp bar exp
				| {logical_exp} exp_logica;

	exp_logica = {equal_exp} [termo1]:exp equal exp
							| {not_equal_exp} [termo1]:exp not_equal exp
							 | {l_equal_exp} [termo1]:exp l_equal exp
							 | {g_equal_exp}[termo1]:exp g_equal exp
							 | {less_exp}[termo1]:exp less exp
							 | {greater_exp}[termo1]:exp greater exp
							 | {not_exp} not exp_logica
							 | {and_exp}[termo1]:exp_logica and exp_logica
							 | {or_exp}[termo1]:exp_logica or exp_logica
							 | {xor_exp}[termo1]:exp_logica xor exp_logica;
*/
