Package portugol;

Helpers
	digit_excluding_zero = ['1'..'9'];
	digit = ['0'..'9'];
	lowercase = ['a'..'z'];
	uppercase = ['A'..'Z'];
	letter = lowercase | uppercase ;
	cr = 13;
	lf = 10;
	tab = 9;
	anything = [0..0xffff];

Tokens
	program = 'programa';
	begin = 'inicio';
	end = 'fim';
	dot = '.';
	colon = ':';
	semicolon = ';';
	const = 'const';
	comma = ',';
	real = 'real';
	integer = 'inteiro';
	char = 'charactere';
	l_bkt = '[';
	r_bkt = ']';
	l_arrow = '<-';
	read = 'leia';
	l_par = '(';
	r_par = ')';
	write = 'escreva';
	if = 'se';
	then = 'entao';
	else = 'senao';
	end_if = 'fim se';
	evaluate = 'avalie';
	case = 'caso';
	end_evaluate = 'fim avalie';
	while = 'enquanto';
	do = 'faca';
	end_while = 'fim enquanto';
	repeat = 'repita';
	until = 'ate';
	for = 'para';
	of = 'de';
	step = 'passo';
	end_for = 'fim para';	
	minus = '-';
	plus = '+';
	star = '*';
	bar = '/';
	equal = '=';
	not_equal = '<>';
	l_equal = '<=';
	g_equal = '>=';
	less = '<';
	greater = '>';
	not = 'nao';
	and = 'e';
	or = 'ou';
	xor = 'xor';

	id = (letter | '_') (letter | digit | '_')*;
	line_comment = '//' [anything - [cr + lf ]]*  (lf cr | lf | cr );
	block_commnet = '/*' [anything - ['*' + '/']]* '*/';
	string = ''' ( letter | digit )* ''';
	vector = (letter | '_') (letter | digit | '_')* '[' digit* ']';
	n_int = '-'? digit_excluding_zero digit*;
	n_real = digit digit* '.' digit digit*;
	blank = (' ' | cr | lf | tab)+;

Ignored Tokens
	blank;


Productions
	programa = program id begin end dot;
/*
	programa = program id begin declaracao* comando* end dot;

	declaracao = tipo colon var_comma* var semicolon;

	var_comma = var comma;

	comando_semicolon = {comando_semicolon} comando semicolon;

	comando_colon = {comando_colon} comando colon;

	exp_comma = exp comma;
	
	tipo =  {real} real|
			{integer} integer| 
			{char} char;

	var = {id} id| id l_bkt n_int r_bkt;

	valor = {string} string | {n_int} n_int | {n_real} n_real;

	else_comando_colon = else comando_colon* comando semicolon;
	else_colon_comando = else colon comando_semicolon* comando semicolon;
	case_valor = case valor colon comando_semicolon* comando semicolon;
	
	comando = {var} var l_arrow exp semicolon
						| {read} read l_par var_comma* var r_par semicolon
						| {write} write l_par exp_comma* exp r_par  
						| {if} if l_par exp_logica r_par then comando_semicolon+ else_comando_colon? end_if semicolon
						| {evaluate} evaluate l_par exp r_par case_valor* else_colon_comando? end_evaluate semicolon
						| {while} while l_par exp_logica r_par do comando_semicolon+ end_while semicolon
						| {repeat} repeat comando_semicolon+ until l_par exp_logica r_par semicolon
						| {for} for var of [startn]:n_int until [end_n]:n_int do comando_semicolon+ end_for semicolon
						| {for_each} var of [startn]:n_int step n_int until [end_n]:n_int do comando_semicolon+ end_for semicolon;

	exp = {valor} valor
				|{exp_var} var
				| {exp_par} l_par exp r_par
				| {negative_exp} minus exp 
				| {add} [termo1]:exp plus exp
				| {subtract} [termo1]:exp minus exp
				| {mult} [termo1]:exp star exp
				| {div} [termo1]:exp bar exp
				| {logical_exp} exp_logica;

	exp_logica = {equal_exp} [termo1]:exp equal exp
							| {not_equal_exp} [termo1]:exp not_equal exp
							 | {l_equal_exp} [termo1]:exp l_equal exp
							 | {g_equal_exp}[termo1]:exp g_equal exp
							 | {less_exp}[termo1]:exp less exp
							 | {greater_exp}[termo1]:exp greater exp
							 | {not_exp} not exp_logica
							 | {and_exp}[termo1]:exp_logica and exp_logica
							 | {or_exp}[termo1]:exp_logica or exp_logica
							 | {xor_exp}[termo1]:exp_logica xor exp_logica;
*/
